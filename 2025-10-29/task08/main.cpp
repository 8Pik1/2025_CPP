// Дан массив из n положительных целых чисел. Требуется определить, сколько пар соседних элементов массива являются взаимно простыми, то есть имеют наибольший общий делитель, равный единице. Среди всех возможных пар различных элементов массива нужно найти такую, для которой числа взаимно просты и произведение этих чисел максимально, после чего вывести найденные элементы или сообщить, что таких пар нет. Далее необходимо проверить, существует ли хотя бы одна тройка соседних элементов x, y и z, для которой первые два и последние два числа взаимно просты, а сумма первого и третьего элемента делится на второй без остатка. Если такая тройка существует, требуется вывести её элементы и их позиции, если нет — сообщить об отсутствии подходящих троек. Затем необходимо построить новый массив той же длины, где на месте каждого элемента записывается единица, если существует другой элемент массива, который либо делится на данный элемент, либо сам делится на него, и ноль в противном случае. В завершение следует вывести полученный массив и сумму его элементов.

#include <iostream>
using namespace std;

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main()
{
    const int n = 8;
    int a[n] = {15, 8, 7, 14, 9, 25, 16, 11};
    
    int cnt = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (gcd(a[i], a[i+1]) == 1) {
            cnt++;
        }
    }
    
    cout << "Пар соседей взаимно простых: " << cnt << '\n';
    
    int max_prod = -1;
    int num1 = -1;
    int num2 = -1;
    
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            if (gcd(a[i], a[j]) == 1) {
                int prod = a[i] * a[j];
                if (prod > max_prod) {
                    max_prod = prod;
                    num1 = a[i];
                    num2 = a[j];
                }
            }
        }
    }
    
    if (max_prod != -1) {
        cout << "Макс произведение взаимно простых: " << num1 << " и " << num2 << '\n';
    }
    else {
        cout << "Нет взаимно простых пар" << '\n';
    }
    
    bool found_triple = false;
    for (int i = 0; i < n - 2; ++i) {
        if (gcd(a[i], a[i+1]) == 1 && gcd(a[i+1], a[i+2]) == 1) {
            if ((a[i] + a[i+2]) % a[i+1] == 0) {
                cout << "Тройка найдена: " << a[i] << " " << a[i+1] << " " << a[i+2] << '\n';
                cout << "Позиции: " << i << " " << i+1 << " " << i+2 << '\n';
                found_triple = true;
                break;
            }
        }
    }
    
    if (!found_triple) {
        cout << "Подходящих троек нет" << '\n';
    }
    
    int b[n] = {0};
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (i != j) {
                if (a[i] % a[j] == 0 || a[j] % a[i] == 0) {
                    b[i] = 1;
                    break;
                }
            }
        }
    }
    
    int sum = 0;
    cout << "Новый массив: ";
    for (int i = 0; i < n; ++i) {
        cout << b[i] << ' ';
        sum += b[i];
    }
    cout << '\n';
    cout << "Сумма: " << sum << '\n';
    
    return 0;
}